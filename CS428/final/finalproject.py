import binascii

#This function will open the keyfile and get the length of the key as well as the key.
def openKey():
    keyFile = open("key.txt", "r")
    try:
        #key = binascii.hexlify(keyFile.read())
        key = keyFile.read()
        

    finally:
        keyFile.close()
    keyTextHex = key.encode('utf-8').hex()

    newList = []
    # print(keyTextHex)
    for i in range(0, len(keyTextHex)):
        
        tempString = int(keyTextHex[i], 16) 
        newList.append(tempString)
    
    return newList

#This function will open the ciphertext file and get the ciphertext.
def openPlainText():
    plainTextFile = open("input.txt", "r")
    try:
        #plainText = binascii.hexlify(plainTextFile.read())
        plainText = plainTextFile.read()

    finally:
        plainTextFile.close()
    plainTextHex = plainText.encode('utf-8').hex()

    newList = []
    # print(plainTextHex)
    for i in range(0, len(plainTextHex)):
        
        tempString = int(plainTextHex[i], 16) 
        newList.append(tempString)
    
    return newList

#This function will will do the add round key portion of the AES algorithm.
def addRoundKey(key, plainText):
    roundKey = []
    for i in range(0, len(plainText)):
        roundKey.append(plainText[i] ^ key[i])
    return roundKey

def generateKeySchedule(key, round):
    rcon = [0x00, 0x00, 0x00, 0x00, 0x10, 0x20, 0x40, 0x80, 0x10, 0x30]
    rcon2 = [0x01, 0x20, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x06]
    word1 = []
    word2 = []
    word3 = []
    word4 = []
    word5 = []
    word6 = []
    word7 = []
    word8 = []
    # setting up the words
    for i in range(0, 4):
        word1.append(key[i*8])
        word1.append(key[i*8 + 1])
        word2.append(key[i*8 + 2])
        word2.append(key[i*8 + 3])
        word3.append(key[i*8 + 4])
        word3.append(key[i*8 + 5])
        word4.append(key[i*8 + 6])
        word4.append(key[i*8 + 7])
    
    # RotWord
    for i in range(0, len(word4)- 2):
        temp = word4[i]
        word4[i] = word4[i+2]
        word4[i+2] = temp

    # SubWord
    for i in range(0, 4):
        word4[i*2], word4[i*2+1] = sBox(word4[i*2], word4[i*2+1]);
    
    # Rcon
    word4[0] = word4[0] ^ rcon[round] 
    word4[1] = word4[1] ^ rcon2[round]
    
    for i in range(0, 8):
        word5.append(word1[i] ^ word4[i])
        word6.append(word5[i] ^ word2[i])
        word7.append(word6[i] ^ word3[i])
        word8.append(word7[i] ^ word4[i])
    # print(word1)
    # print(word2)
    # print(word3)
    # print(word4)
    return word5 + word6 + word7 + word8

def sBox(input1, input2):
    
    sBox = [[0x6, 0x7, 0x7, 0x7, 0xF, 0x6, 0x6, 0xC, 0x3, 0x0, 0x6, 0x2, 0xF, 0xD, 0xA, 0x7],
            [0xC, 0x8, 0xC, 0x7, 0xF, 0x5, 0x4, 0xF, 0xA, 0xD, 0xA, 0xA, 0x9, 0xA, 0x7, 0xC,],
            [0xB, 0xF, 0x9, 0x2, 0x3, 0x3, 0xF, 0xC, 0x3, 0xA, 0xE, 0xF, 0x7, 0xD, 0x3, 0x1,],
            [0x0, 0xC, 0x2, 0xC, 0x1, 0x9, 0x0, 0x9, 0x0, 0x1, 0x8, 0xE, 0xE, 0x2, 0xB, 0x7,],
            [0x0, 0x8, 0x2, 0x1, 0x1, 0x6, 0x5, 0xA, 0x5, 0x3, 0xD, 0xB, 0x2, 0xE, 0x2, 0x8,],
            [0x5, 0xD, 0x0, 0xE, 0x2, 0xF, 0xB, 0x5, 0x6, 0xC, 0xB, 0x3, 0x4, 0x4, 0x5, 0xC,],
            [0xD, 0xE, 0xA, 0xF, 0x4, 0x4, 0x3, 0x8, 0x4, 0xF, 0x0, 0x7, 0x5, 0x3, 0x9, 0xA,],
            [0x5, 0xA, 0x4, 0x8, 0x9, 0x9, 0x3, 0xF, 0xB, 0xB, 0xD, 0x2, 0x1, 0xF, 0xF, 0xD,],
            [0xC, 0x0, 0x1, 0xE, 0x5, 0x9, 0x4, 0x1, 0xC, 0xA, 0x7, 0x3, 0x6, 0x5, 0x1, 0x7,],
            [0x6, 0x8, 0x4, 0xD, 0x2, 0x2, 0x9, 0x8, 0x4, 0xE, 0xB, 0x1, 0xD, 0x5, 0x0, 0xD,],
            [0xE, 0x3, 0x3, 0x0, 0x4, 0x0, 0x2, 0x5, 0xC, 0xD, 0xA, 0x6, 0x9, 0x9, 0xE, 0x7,],
            [0xE, 0xC, 0x3, 0x6, 0x8, 0xD, 0x4, 0xA, 0x6, 0x5, 0xF, 0xE, 0x6, 0x7, 0xA, 0x0,],
            [0xB, 0x7, 0x2, 0x2, 0x1, 0xA, 0xB, 0xC, 0xE, 0xD, 0x7, 0x1, 0x4, 0xB, 0x8, 0x8,],
            [0x7, 0x3, 0xB, 0x6, 0x4, 0x0, 0xF, 0x0, 0x6, 0x3, 0x5, 0xB, 0x8, 0xC, 0x1, 0x9,],
            [0xE, 0xF, 0x9, 0x1, 0x6, 0xD, 0x8, 0x9, 0x9, 0x1, 0x8, 0xE, 0xC, 0x5, 0x2, 0xD,],
            [0x8, 0xA, 0x8, 0x0, 0xB, 0xE, 0x4, 0x6, 0x4, 0x9, 0x2, 0x0, 0xB, 0x5, 0xB, 0x1]]
    
    sBox2 =[[0x3, 0xC, 0x7, 0xB, 0x2, 0xB, 0xF, 0x5, 0x0, 0x1, 0x7, 0xB, 0xE, 0x7, 0xB, 0x6],
            [0xA, 0x2, 0x9, 0xD, 0xA, 0x9, 0x7, 0x0, 0xD, 0x4, 0x2, 0xF, 0xC, 0x4, 0x2, 0x0,],
            [0x7, 0xD, 0x3, 0x6, 0x6, 0xF, 0x7, 0xC, 0x4, 0x5, 0x5, 0x1, 0x1, 0x8, 0x1, 0x5,],
            [0x4, 0x7, 0x3, 0x3, 0x8, 0x6, 0x5, 0xA, 0x7, 0x2, 0x0, 0x2, 0xB, 0x7, 0x2, 0x5,],
            [0x9, 0x3, 0xC, 0xA, 0xB, 0xE, 0xA, 0x0, 0x2, 0xB, 0x6, 0x3, 0x9, 0x3, 0xF, 0x4,],
            [0x3, 0x1, 0x0, 0xD, 0x0, 0xC, 0x1, 0xB, 0xA, 0xB, 0xE, 0x9, 0xA, 0xC, 0x8, 0xF,],
            [0x0, 0xF, 0xA, 0xB, 0x3, 0xD, 0x3, 0x5, 0x5, 0x9, 0x2, 0xF, 0x0, 0xC, 0xF, 0x8,],
            [0x1, 0x3, 0x0, 0xF, 0x2, 0xD, 0x8, 0x5, 0xC, 0x6, 0xA, 0x1, 0x0, 0xF, 0x3, 0x2,],
            [0xD, 0xC, 0x3, 0xC, 0xF, 0x7, 0x4, 0x7, 0x4, 0x7, 0xE, 0xD, 0x4, 0xD, 0x9, 0x3,],
            [0x0, 0x1, 0xF, 0xC, 0x2, 0xA, 0x0, 0x8, 0x6, 0xE, 0x8, 0x4, 0xE, 0xE, 0xB, 0xB,],
            [0x0, 0x2, 0xA, 0xA, 0x9, 0x6, 0x4, 0xC, 0x2, 0x3, 0xC, 0x2, 0x1, 0x5, 0x4, 0x9,],
            [0x7, 0x8, 0x7, 0xD, 0xD, 0x5, 0xE, 0x9, 0xC, 0x6, 0x4, 0xA, 0x5, 0xA, 0xE, 0x8,],
            [0xA, 0x8, 0x5, 0xE, 0xC, 0x6, 0x4, 0x6, 0x8, 0xD, 0x4, 0xF, 0xB, 0xD, 0xB, 0xA,],
            [0x0, 0xE, 0x5, 0x6, 0x8, 0x3, 0x6, 0xE, 0x1, 0x5, 0x7, 0x9, 0x6, 0x1, 0xD, 0xE,],
            [0x1, 0x8, 0x8, 0x1, 0x9, 0x9, 0xE, 0x4, 0xB, 0xE, 0x7, 0x9, 0xE, 0x5, 0x8, 0xF,],
            [0xC, 0x1, 0x9, 0xD, 0xF, 0x6, 0x2, 0x8, 0x1, 0x9, 0xD, 0xF, 0x0, 0x4, 0xB, 0x6]]

    # print(input1, input2)
    return sBox[input1%16][input2%16], sBox2[input1%16][input2%16]
    #return int(hex(sBox[input1][input2])[2:]), int(hex(sBox2[input1][input2])[2:])

def sBoxInv(input1, input2):
    sBox = [[0x5, 0x0, 0x6, 0xD, 0x3, 0x3, 0xA, 0x3, 0xB, 0x4, 0xA, 0x9, 0x8, 0xF, 0xD, 0xF],
            [0x7, 0xE, 0x3, 0x8, 0x9, 0x2, 0xF, 0x8, 0x3, 0x8, 0x4, 0x4, 0xC, 0xD, 0xE, 0xC],
            [0x5, 0x7, 0x9, 0x3, 0xA, 0xC, 0x2, 0x3, 0xE, 0x4, 0x9, 0x0, 0x4, 0xF, 0xC, 0x4],
            [0x0, 0x2, 0xA, 0x6, 0x2, 0xD, 0x2, 0xB, 0x7, 0x5, 0xA, 0x4, 0x6, 0x8, 0xD, 0x2,],
            [0x7, 0xF, 0xF, 0x6, 0x8, 0x6, 0x9, 0x1, 0xD, 0xA, 0x5, 0xC, 0x5, 0x6, 0xB, 0x9,],
            [0x6, 0x7, 0x4, 0x5, 0xF, 0xE, 0xB, 0xD, 0x5, 0x1, 0x4, 0x5, 0xA, 0x8, 0x9, 0x8,],
            [0x9, 0xD, 0xA, 0x0, 0x8, 0xB, 0xD, 0x0, 0xF, 0xE, 0x5, 0x0, 0xB, 0xB, 0x4, 0x0,],
            [0xD, 0x2, 0x1, 0x8, 0xC, 0x3, 0x0, 0x0, 0xC, 0xA, 0xB, 0x0, 0x0, 0x1, 0x8, 0x6,],
            [0x3, 0x9, 0x1, 0x4, 0x4, 0x6, 0xD, 0xE, 0x9, 0xF, 0xC, 0xC, 0xF, 0xB, 0xE, 0x7,],
            [0x9, 0xA, 0x7, 0x2, 0xE, 0xA, 0x3, 0x8, 0xE, 0xF, 0x3, 0xE, 0x1, 0x7, 0xD, 0x6,],
            [0x4, 0xF, 0x1, 0x7, 0x1, 0x2, 0xC, 0x8, 0x6, 0xB, 0x6, 0x0, 0xA, 0x1, 0xB, 0x1,],
            [0xF, 0x5, 0x3, 0x4, 0xC, 0xD, 0x7, 0x2, 0x9, 0xD, 0xC, 0xF, 0x7, 0xC, 0x5, 0xF,],
            [0x1, 0xD, 0xA, 0x3, 0x8, 0x0, 0xC, 0x3, 0xB, 0x1, 0x1, 0x5, 0x2, 0x8, 0xE, 0x5,],
            [0x6, 0x5, 0x7, 0xA, 0x1, 0xB, 0x4, 0x0, 0x2, 0xE, 0x7, 0x9, 0x9, 0xC, 0x9, 0xE,],
            [0xA, 0xE, 0x3, 0x4, 0xA, 0x2, 0xF, 0xB, 0xC, 0xE, 0xB, 0x3, 0x8, 0x5, 0x9, 0x6,],
            [0x1, 0x2, 0x0, 0x7, 0xB, 0x7, 0xD, 0x2, 0xE, 0x6, 0x1, 0x6, 0x5, 0x2, 0x0, 0x7]]
    
    sBox2 =[[0x2, 0x9, 0xA, 0x5, 0x0, 0x6, 0x5, 0x8, 0xF, 0x0, 0x3, 0xE, 0x1, 0x3, 0x7, 0xB],
            [0xC, 0x3, 0x9, 0x2, 0xB, 0xF, 0xF, 0x7, 0x4, 0xE, 0x3, 0x4, 0x4, 0xE, 0x9, 0xB],
            [0x4, 0xB, 0x4, 0x2, 0x6, 0x2, 0x3, 0xD, 0xE, 0xC, 0x5, 0xB, 0x2, 0xA, 0x3, 0xE],
            [0x8, 0xE, 0x1, 0x6, 0x8, 0x9, 0x4, 0x2, 0x6, 0xB, 0x2, 0x9, 0xD, 0xB, 0x1, 0x5,],
            [0x2, 0x8, 0x6, 0x4, 0x6, 0x8, 0x8, 0x6, 0x4, 0x4, 0xC, 0xC, 0xD, 0x5, 0x6, 0x2,],
            [0xC, 0x0, 0x8, 0x0, 0xD, 0xD, 0x9, 0xA, 0xE, 0x5, 0x6, 0x7, 0x7, 0xD, 0xD, 0x4,],
            [0x0, 0x8, 0xB, 0x0, 0xC, 0xC, 0x3, 0xA, 0x7, 0x4, 0x8, 0x5, 0x8, 0x3, 0x5, 0x6,],
            [0x0, 0xC, 0xE, 0xF, 0xA, 0xF, 0xF, 0x2, 0x1, 0xF, 0xD, 0x3, 0x1, 0x3, 0xA, 0xB,],
            [0xA, 0x1, 0x1, 0x1, 0xF, 0x7, 0xC, 0xA, 0x7, 0x2, 0xF, 0xE, 0x0, 0x4, 0x6, 0x3,],
            [0x6, 0xC, 0x4, 0x2, 0x7, 0xD, 0x5, 0x5, 0x2, 0x9, 0x7, 0x8, 0xC, 0x5, 0xF, 0xE,],
            [0x7, 0x1, 0xA, 0x1, 0xD, 0x9, 0x5, 0x9, 0xF, 0x7, 0x2, 0xE, 0xA, 0x8, 0xE, 0xB,],
            [0xC, 0x6, 0xE, 0xB, 0x6, 0x2, 0x9, 0x0, 0xA, 0xB, 0x0, 0xE, 0x8, 0xD, 0xA, 0x4,],
            [0xF, 0xD, 0x8, 0x3, 0x8, 0x7, 0x7, 0x1, 0x1, 0x2, 0x0, 0x9, 0x7, 0x0, 0xC, 0xF,],
            [0x0, 0x1, 0xF, 0x9, 0x9, 0x5, 0xA, 0xD, 0xD, 0x5, 0xA, 0xF, 0x3, 0x9, 0xC, 0xF,],
            [0x0, 0x0, 0xB, 0xD, 0xE, 0xA, 0x5, 0x0, 0x8, 0xB, 0xB, 0xC, 0x3, 0x3, 0x9, 0x1,],
            [0x7, 0xB, 0x4, 0xE, 0xA, 0x7, 0x6, 0x6, 0x1, 0x9, 0x4, 0x3, 0x5, 0x1, 0xC, 0xD]]

    # print(input1, input2)
    return sBox[input1%16][input2%16], sBox2[input1%16][input2%16]


def correctInput(input1, input2):
    input = [[0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F],
            [0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F],
            [0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F],
            [0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F],
            [0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F],
            [0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F],
            [0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F],
            [0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F],
            [0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F],
            [0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F],
            [0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF],
            [0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF],
            [0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF],
            [0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF],
            [0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF],
            [0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE]]
    return input[input1][input2]




def encrypt(plainText, key):
    state = addRoundKey(key, plainText)
    print(state)
    for i in range(0, 10):
        state = subBytesShift(state)
        # if i != 9:
        #     state = mixColumns(state)
            # print(state)
        state = addRoundKey(generateKeySchedule(key, i), state)
        print("Round " + str(i+1) + ": ")
        # print(state)
    return state

def decrypt(cipherText, key):
    state = addRoundKey(key, cipherText)
    for i in range(0, 10):
        state = subBytesInvShift(state)
        # if i != 9:
        #     state = mixColumns(state)
            # print(state)
        state = addRoundKey(generateKeySchedule(key, i), state)
        print("Round " + str(i+1) + ": ")
        # print(state)
    return state

def subBytesShift(state):
    word1 = []
    word2 = []
    word3 = []
    word4 = []
    for i in range(0, 4):
        word1.append(state[i*8])
        word1.append(state[i*8 + 1])
        word2.append(state[i*8 + 2])
        word2.append(state[i*8 + 3])
        word3.append(state[i*8 + 4])
        word3.append(state[i*8 + 5])
        word4.append(state[i*8 + 6])
        word4.append(state[i*8 + 7])
    
    for i in range(0, 4):
        word1[i*2], word1[i*2+1] = sBox(word1[i*2], word1[i*2+1]);
        word2[i*2], word2[i*2+1] = sBox(word2[i*2], word2[i*2+1]);
        word3[i*2], word3[i*2+1] = sBox(word3[i*2], word3[i*2+1]);
        word4[i*2], word4[i*2+1] = sBox(word4[i*2], word4[i*2+1]);
    
    for i in range(0, len(word1)- 2):
        temp = word1[i]
        word1[i] = word1[i+2]
        word1[i+2] = temp
    for i in range(0, len(word2)- 2):
        temp = word2[i]
        word2[i] = word2[i+2]
        word2[i+2] = temp
    for i in range(0, len(word3)- 2):
        temp = word3[i]
        word3[i] = word3[i+2]
        word3[i+2] = temp
    for i in range(0, len(word4)- 2):
        temp = word4[i]
        word4[i] = word4[i+2]
        word4[i+2] = temp
    
    return word1 + word2 + word3 + word4


def mixColumns(state):

    word1 = []
    word2 = []
    word3 = []
    word4 = []
    for i in range(0, 4):
        word1.append(state[i*8])
        word1.append(state[i*8 + 1])
        word2.append(state[i*8 + 2])
        word2.append(state[i*8 + 3])
        word3.append(state[i*8 + 4])
        word3.append(state[i*8 + 5])
        word4.append(state[i*8 + 6])
        word4.append(state[i*8 + 7])
    
    
    a1 = word1[0] + word1[1]
    b1 = word1[2] + word1[3]
    c1 = word1[4] + word1[5]
    d1 = word1[6] + word1[7]
    #This code came from https://stackoverflow.com/questions/66115739/aes-mixcolumns-with-python
    word1[0] = ((gmul(a1, 2) ^ gmul(b1, 3) ^ gmul(c1, 1) ^ gmul(d1, 1)) / 16) % 16
    word1[1] =  (gmul(a1, 2) ^ gmul(b1, 3) ^ gmul(c1, 1) ^ gmul(d1, 1)) % 16
    word1[2] = ((gmul(a1, 1) ^ gmul(b1, 2) ^ gmul(c1, 3) ^ gmul(d1, 1)) / 16 ) % 16
    word1[3] =  (gmul(a1, 1) ^ gmul(b1, 2) ^ gmul(c1, 3) ^ gmul(d1, 1)) % 16
    word1[4] = ((gmul(a1, 1) ^ gmul(b1, 1) ^ gmul(c1, 2) ^ gmul(d1, 3)) / 16 ) % 16
    word1[5] =  (gmul(a1, 1) ^ gmul(b1, 1) ^ gmul(c1, 2) ^ gmul(d1, 3)) % 16
    word1[6] = ((gmul(a1, 3) ^ gmul(b1, 1) ^ gmul(c1, 1) ^ gmul(d1, 2))) / 16 % 16
    word1[7] =  (gmul(a1, 3) ^ gmul(b1, 1) ^ gmul(c1, 1) ^ gmul(d1, 2)) % 16

    a2 = word2[0] + word2[1]
    b2 = word2[2] + word2[3]
    c2 = word2[4] + word2[5]
    d2 = word2[6] + word2[7]
    #This code came from https://stackoverflow.com/questions/66115739/aes-mixcolumns-with-python
    word2[0] = ((gmul(a2, 2) ^ gmul(b2, 3) ^ gmul(c2, 1) ^ gmul(d2, 1)) / 16) % 16
    word2[1] =  (gmul(a2, 2) ^ gmul(b2, 3) ^ gmul(c2, 1) ^ gmul(d2, 1)) % 16
    word2[2] = ((gmul(a2, 1) ^ gmul(b2, 2) ^ gmul(c2, 3) ^ gmul(d2, 1)) / 16 ) % 16
    word2[3] =  (gmul(a2, 1) ^ gmul(b2, 2) ^ gmul(c2, 3) ^ gmul(d2, 1)) % 16
    word2[4] = ((gmul(a2, 1) ^ gmul(b2, 1) ^ gmul(c2, 2) ^ gmul(d2, 3)) / 16 ) % 16
    word2[5] =  (gmul(a2, 1) ^ gmul(b2, 1) ^ gmul(c2, 2) ^ gmul(d2, 3)) % 16
    word2[6] = ((gmul(a2, 3) ^ gmul(b2, 1) ^ gmul(c2, 1) ^ gmul(d2, 2))) / 16 % 16
    word2[7] =  (gmul(a2, 3) ^ gmul(b2, 1) ^ gmul(c2, 1) ^ gmul(d2, 2)) % 16

    a3 = word3[0] + word3[1]
    b3 = word3[2] + word3[3]
    c3 = word3[4] + word3[5]
    d3 = word3[6] + word3[7]
    #This code came from https://stackoverflow.com/questions/66115739/aes-mixcolumns-with-python
    word3[0] = ((gmul(a3, 2) ^ gmul(b3, 3) ^ gmul(c3, 1) ^ gmul(d3, 1)) / 16) % 16
    word3[1] =  (gmul(a3, 2) ^ gmul(b3, 3) ^ gmul(c3, 1) ^ gmul(d3, 1)) % 16
    word3[2] = ((gmul(a3, 1) ^ gmul(b3, 2) ^ gmul(c3, 3) ^ gmul(d3, 1)) / 16 ) % 16
    word3[3] =  (gmul(a3, 1) ^ gmul(b3, 2) ^ gmul(c3, 3) ^ gmul(d3, 1)) % 16
    word3[4] = ((gmul(a3, 1) ^ gmul(b3, 1) ^ gmul(c3, 2) ^ gmul(d3, 3)) / 16 ) % 16
    word3[5] =  (gmul(a3, 1) ^ gmul(b3, 1) ^ gmul(c3, 2) ^ gmul(d3, 3)) % 16
    word3[6] = ((gmul(a3, 3) ^ gmul(b3, 1) ^ gmul(c3, 1) ^ gmul(d3, 2))) / 16 % 16
    word3[7] =  (gmul(a3, 3) ^ gmul(b3, 1) ^ gmul(c3, 1) ^ gmul(d3, 2)) % 16

    a4 = word4[0] + word4[1]
    b4 = word4[2] + word4[3]
    c4 = word4[4] + word4[5]
    d4 = word4[6] + word4[7]
    #This code came from https://stackoverflow.com/questions/66115739/aes-mixcolumns-with-python
    word4[0] = ((gmul(a4, 2) ^ gmul(b4, 3) ^ gmul(c4, 1) ^ gmul(d4, 1)) / 16) % 16
    word4[1] =  (gmul(a4, 2) ^ gmul(b4, 3) ^ gmul(c4, 1) ^ gmul(d4, 1)) % 16
    word4[2] = ((gmul(a4, 1) ^ gmul(b4, 2) ^ gmul(c4, 3) ^ gmul(d4, 1)) / 16 ) % 16
    word4[3] =  (gmul(a4, 1) ^ gmul(b4, 2) ^ gmul(c4, 3) ^ gmul(d4, 1)) % 16
    word4[4] = ((gmul(a4, 1) ^ gmul(b4, 1) ^ gmul(c4, 2) ^ gmul(d4, 3)) / 16 ) % 16
    word4[5] =  (gmul(a4, 1) ^ gmul(b4, 1) ^ gmul(c4, 2) ^ gmul(d4, 3)) % 16
    word4[6] = ((gmul(a4, 3) ^ gmul(b4, 1) ^ gmul(c4, 1) ^ gmul(d4, 2))) / 16 % 16
    word4[7] =  (gmul(a4, 3) ^ gmul(b4, 1) ^ gmul(c4, 1) ^ gmul(d4, 2)) % 16

    return word1, word2, word3, word4
def gmul(a, b):
    if b == 1:
        return a
    tmp = (a << 1) & 0xff
    if b == 2:
        return tmp if a < 128 else tmp ^ 0x1b
    if b == 3:
        return gmul(a, 2) ^ a
    
    
def subBytesInvShift(state):
    word1 = []
    word2 = []
    word3 = []
    word4 = []
    for i in range(0, 4):
        word1.append(state[i*8])
        word1.append(state[i*8 + 1])
        word2.append(state[i*8 + 2])
        word2.append(state[i*8 + 3])
        word3.append(state[i*8 + 4])
        word3.append(state[i*8 + 5])
        word4.append(state[i*8 + 6])
        word4.append(state[i*8 + 7])

    for i in range(2, 8):
        temp = word2[i]
        word2[i] = word2[i-2]
        word2[i-2] = temp
    for i in range(4, 8):
        temp = word3[i]
        word3[i] = word3[i-4]
        word3[i-4] = temp
    for i in range(6, 8):
        temp = word4[i]
        word4[i] = word4[i-6]
        word4[i-6] = temp
    
    for i in range(0, 4):
        word1[i*2], word1[i*2+1] = sBoxInv(word1[i*2], word1[i*2+1]);
        word2[i*2], word2[i*2+1] = sBoxInv(word2[i*2], word2[i*2+1]);
        word3[i*2], word3[i*2+1] = sBoxInv(word3[i*2], word3[i*2+1]);
        word4[i*2], word4[i*2+1] = sBoxInv(word4[i*2], word4[i*2+1]);
    
    
    
    return word1 + word2 + word3 + word4


def main():
    key = openKey()
    # key, plainText = test()
    plainText = openPlainText()
    # keyLength *= 4
    decplainttext = plainText
    print("Key Length: ")
    # print(keyLength)
    print("Key: ")
    print(key)
    print("Plaintext: ")
    print(plainText)
    state = encrypt(plainText, key)
    print("Ciphertext: ")
    print(state)
    decplaintext = decrypt(state, key)
    print(plainText)
    print("Decrypted Ciphertext: ")
    print(decplainttext)

main()